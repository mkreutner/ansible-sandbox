# 5. Blocs et instructions de secours

## 5.1. Utilisation des blocs dans les playbooks

Les blocs permettent de regrouper logiquement des tâches et d'offrir des moyens de gérer les erreurs, similaire à la gestion des exceptions dans de nombreux langages de programmation.

Toutes les tâches dans un bloc héritent des directives appliquées au niveau du bloc. La plupart des directives que vous pouvez appliquer à une seule tâche (à l'exception des boucles) peuvent être appliquées au niveau du bloc. Cela rend les blocs utiles pour définir des données ou des directives communes aux tâches.

Par exemple : 

```YAML
- name: Example block
  hosts: all
  tasks:
  - name: Install and start NGINX
    block:
      - name: Install NGINX
        ansible.builtin.apt:
          name: nginx
          state: present

      - name: Start and activate NGINX
        ansible.builtin.service:
          name: nginx
          state: started
          enabled: True
    when: ansible_facts['os_family'] == 'Debian'
    become: true
    become_user: root
    ignore_errors: true
```

- La condition **when** est évaluée avant l'exécution de chaque tâche dans le bloc.
- Toutes les tâches héritent des directives d'escalade de privilèges, s'exécutant en tant qu'utilisateur root.
- i**gnore_errors: true** garantit que le **playbook** continue de s'exécuter même si certaines tâches échouent.

## 5.2. Gestion des erreurs avec des blocs

Vous pouvez contrôler la manière dont **Ansible** réagit aux erreurs des tâches en utilisant des blocs avec **rescue** et **always**.

### 5.2.1. Utilisation de rescue

Si une tâche du bloc échoue, la section **rescue** s'exécute pour gérer l'erreur.

```YAML
- name: Example of a block with rescue
  hosts: all
  tasks:
  - name: Managing errors
    block:
      - name: Display a message
        ansible.builtin.debug:
          msg: "I carry out normally"

      - name: Force an error
        ansible.builtin.command: /bin/false

      - name: Never display this
        ansible.builtin.debug:
          msg: "I never carry out the task because of the failure of the previous one."
    rescue:
      - name: Display a message if an error occurs
        ansible.builtin.debug:
          msg: "I've captured an error; I can do something to fix it."
```

### 5.2.2. Utilisation de always

Les tâches de la section **always** s'exécutent indépendamment du statut des tâches du bloc.

```YAML
- name: Example block with always
  hosts: all
  tasks:
  - name: Always do X
    block:
      - name: Display a message
        ansible.builtin.debug:
          msg: "I carry out normally"

      - name: Force an error
        ansible.builtin.command: /bin/false

      - name: Never display this
        ansible.builtin.debug:
          msg: "I never comply"
    always:
      - name: Always perform this task
        ansible.builtin.debug:
          msg: "This task always runs"
```

### 5.2.3. Combinaison des deux

```YAML
- name: Example of a block with always and rescue
  hosts: all
  tasks:
  - name: Demonstration of a graceful attempt and retreat
    block:
      - name: Display a message
        ansible.builtin.debug:
          msg: "I carry out normally"

      - name: Force an error
        ansible.builtin.command: /bin/false

      - name: Never display this
        ansible.builtin.debug:
          msg: "I never carry out the task because of the failure of the previous one."
    rescue:
      - name: Display a message if an error occurs
        ansible.builtin.debug:
          msg: "I catched an error"

      - name: Force a new error during recovery
        ansible.builtin.command: /bin/false

      - name: Never display this either
        ansible.builtin.debug:
          msg: "I never comply"
    always:
      - name: Always perform this task
        ansible.builtin.debug:
          msg: "This task always runs"
```

### 5.2.4. Les variables disponibles dans rescue

**Ansible** fournit deux variables spéciales dans la section rescue d'un bloc : **ansible_failed_task** et **ansible_failed_result**.

Ces variables permettent d'accéder aux détails de la tâche ayant échoué et au résultat capturé de cette tâche. Cela offre une flexibilité supplémentaire pour gérer les erreurs et prendre des décisions basées sur des informations spécifiques sur l'échec.

#### ansible_failed_task

La variable **ansible_failed_task** contient des informations sur la tâche qui a échoué et qui a déclenché la section **rescue**.

Cela inclut des détails tels que le nom de la tâche, le module utilisé, et d'autres attributs de la tâche.

```YAML
- name: Example block with ansible_failed_task
  hosts: all
  tasks:
  - name: Task execution with error handling
    block:
      - name: Check if a user exists in /etc/passwd
        ansible.builtin.command: grep "testuser42" /etc/passwd
    rescue:
      - name: Display the name of the failed task
        ansible.builtin.debug:
          msg: "The task that failed is: {{ ansible_failed_task.name }}"
```

#### ansible_failed_result

La variable **ansible_failed_result** contient le résultat capturé de la tâche qui a échoué.

Cela inclut des informations telles que le code de retour (**rc**), la sortie standard (**stdout**), et la sortie d'erreur (**stderr**) de la tâche ayant échoué.

```YAML
- name: Example block with ansible_failed_result
  hosts: all
  tasks:
  - name: Task execution with error handling
    block:
      - name: Check if a file exists
        ansible.builtin.command: ls /nonexistentfile
    rescue:
      - name: Display the return code of the failed task
        ansible.builtin.debug:
          msg: "The return code for the failed task is: {{ ansible_failed_result.rc }}"

      - name: Display the error output of the failed task
        ansible.builtin.debug:
          msg: "The error output for the failed task is: {{ ansible_failed_result.stderr }}"
```

Vous pouvez utiliser des conditions pour effectuer des actions ou afficher des messages différents en fonction des erreurs, par exemple :

```YAML
- name: Example block with ansible_failed_result and ansible_failed_task
  hosts: all
  become: yes
  tasks:
    - name: File management
      block:
        - name: Check if the /etc/passwd file contains 'testuser42'
          ansible.builtin.shell: grep "testuser42" /etc/passwd
          register: grep_result
          failed_when: grep_result.rc != 0
      rescue:
        - name: Check if the failure originates from the grep task.
          when: ansible_failed_task.name == "Check if the /etc/passwd file contains 'testuser42'"
          ansible.builtin.debug:
            msg: "Failure due to user verification testuser42"
        - name: Display the return code if the failure is due to the grep command.
          when: ansible_failed_result.rc == 1
          ansible.builtin.debug:
            msg: "The return code is 1, indicating that the user testuser42 was not found in /etc/passwd."
        - name: Display the contents of stderr if the failure is due to another reason
          when: ansible_failed_result.rc > 1
          ansible.builtin.debug:
            msg: "The failure is due to an error other than 'user not found'. Contents of stderr: {{ ansible_failed_result.stderr }}"
```