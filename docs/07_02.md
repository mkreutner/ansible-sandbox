# 2. Les filtres

## 2.1. Les filtres

Les filtres dans **Ansible** permettent de modifier les valeurs des variables. Ces filtres sont appliqués à la variable en utilisant le symbole pipe (`|`), qui sert de séparateur entre la variable et le filtre.

Il est possible de chaîner plusieurs filtres, où la sortie d'un filtre devient l'entrée du suivant.

Par exemple, l'expression `{{ name|striptags|title }}` utilise deux filtres sur la variable `name` :

1. **striptags** : ce filtre enlève tous les tags **HTML** de la valeur de la variable.
2. **title** : ce filtre transforme la première lettre de chaque mot en majuscule et le reste en minuscule.

Ainsi, si `name` contenait "<p>john doe</p>", le résultat après application des filtres serait "John Doe".

Certains filtres acceptent des arguments, qui doivent être inclus entre parenthèses, similairement à un appel de fonction.

Par exemple, `{{ listx|join(', ') }}` utilise le filtre `join`, qui concatène les éléments d'une liste en une seule chaîne de caractères, séparés par ce qui est spécifié comme argument, ici une virgule suivie d'un espace.

Cela équivaut à l'appel de la méthode `str.join(', ', listx)` en Python.

**Ansible** utilise un grand nombre de filtres pour manipuler et transformer des données.

Ces filtres proviennent principalement de deux sources : ceux inclus avec Jinja2 (le moteur de templating qu'utilise **Ansible**) et ceux spécifiquement développés pour **Ansible**.

Il existe aussi de nombreux filtres développés par la communauté mais nous le verrons pas dans cette leçon car cela en ferait plusieurs centaines.

## 2.2. Filtres Jinja2

### Manipulation de nombres

- **abs()** : Retourne la valeur absolue d'un nombre.
- **max()** : Retourne le maximum d'une liste de nombres.
- **min()** : Retourne le minimum d'une liste de nombres.
- **round()** : Arrondit un nombre à un nombre spécifié de décimales.
- **sum()** : Calcule la somme des éléments d'une liste.

### Manipulation de chaînes

- **capitalize()** : Met la première lettre en majuscule et le reste en minuscule.
- **center()** : Centre une chaîne dans un champ d'une certaine largeur.
- **escape()** : Convertit les caractères en entités HTML.
- **forceescape()** : Force l'échappement des chaînes pour les rendre sûres en HTML.
- **format()** : Formate les variables dans une chaîne.
- **indent()** : Indente une chaîne.
- **lower()** : Convertit une chaîne en minuscules.
- **replace()** : Remplace des sous-chaînes dans une chaîne.
- **safe()** : Marque une chaîne comme sûre pour ne pas être échappée en HTML.
- **string()** : Convertit une valeur en chaîne.
- **title()** : Transforme chaque mot pour que sa première lettre soit en majuscule.
- **trim()** : Supprime les espaces blancs au début et à la fin d'une chaîne.
- **truncate()** : Tronque une chaîne à un nombre spécifié de caractères.
- **upper()** : Convertit une chaîne en majuscules.
- **urlencode()** : Encode une chaîne pour l'utilisation dans une URL.
- **urlize()** : Convertit les URL et les adresses e-mail en liens HTML.
- **wordcount()** : Compte les mots dans une chaîne.
- **wordwrap()** : Enveloppe les mots d'une chaîne à une largeur spécifiée.

### Manipulation de listes et d'objets

- **batch()** : Groupe une liste d'éléments en listes plus petites de taille donnée.
- **dictsort()** : Trie un dictionnaire par ses clés.
- **first()** : Renvoie le premier élément d'une liste.
- **groupby()** : Regroupe une liste d'objets par un attribut commun.
- **join()** : Joint les éléments d'une liste dans une chaîne, séparés par un délimiteur.
- **last()** : Renvoie le dernier élément d'une liste.
- **list()** : Convertit un ensemble de valeurs en liste.
- **map()** : Applique un filtre ou une fonction à chaque élément d'une liste.
- **random()** : Sélectionne un élément aléatoire d'une liste.
- **reject()** : Filtre une liste, en excluant les éléments qui passent un test.
- **rejectattr()** : Filtre une liste d'objets en excluant ceux dont un attribut spécifique passe un test.
- **select()** : Filtre une liste, incluant seulement les éléments qui passent un test.
- **selectattr()** : Filtre une liste d'objets en incluant ceux dont un attribut spécifique passe un test.
- **slice()** : Découpe une liste en listes de taille égale.
- **sort()** : Trie une liste.
- **unique()** : Élimine les doublons d'une liste.

### Manipulation des données et formats

- **default()** : Fournit une valeur par défaut pour une variable non définie.
- **items()** : Renvoie une liste de paires (clé, valeur) d'un dictionnaire.
- **pprint()** : Affiche une représentation formatée pour le débogage.
- **tojson()** : Convertit un objet en chaîne JSON formatée.
- **filesizeformat()** : Formate une taille de fichier en une chaîne lisible par l'humain.
- **length()** : Renvoie la longueur d'une chaîne ou le nombre d'éléments d'une liste.
- **reverse()** : Inverse les éléments d'une liste.
- **float()** : Convertit une valeur en nombre à virgule flottante.
- **int()** : Convertit une valeur en entier.
- **xmlattr()** : Formate les dictionnaires en attributs XML.

## 2.3. Filtres spécifiques à Ansible

Il en existe 70 différents.

### Conversion de données

- **to_json**, **to_nice_json**: Convertissent des structures de données en chaînes JSON, to_nice_json en formatant joliment.
- **to_yaml**, **to_nice_yaml**: Convertissent des structures de données en chaînes YAML, to_nice_yaml en formatant joliment.
- **from_json**: Convertit une chaîne JSON en structure de données.
- **from_yaml**, **from_yaml_all**: Convertit une ou plusieurs chaînes YAML en structures de données.
- **bool**: Convertit une valeur en booléen.

### Manipulation de listes et dictionnaires

- **combinations**, permutations: Génèrent des combinaisons ou permutations des éléments d'une liste.
- **combine**: Fusionne deux dictionnaires.
- **dict2items**: Convertit un dictionnaire en liste de paires clé-valeur.
- **items2dict**: Transforme une liste de paires clé-valeur en dictionnaire.
- **flatten**: Aplatit les listes imbriquées en une seule liste.
- **zip**, **zip_longest**: Combinent les éléments de plusieurs listes, zip_longest permet de gérer des listes de tailles différentes en remplissant les espaces manquants.
- **rekey_on_member**: Réorganise une liste de dictionnaires en un dictionnaire utilisant un membre spécifique.

### Manipulation de chaînes de caractères

- **split**, **splitext**: Divisent une chaîne en liste ou séparent une extension de fichier.
- **regex_search**, **regex_replace**, **regex_findall**, **regex_escape**: Effectuent des opérations avec des expressions régulières comme extraire, remplacer, lister des correspondances ou échapper des caractères spéciaux.
- **quote**: Ajoute des guillemets pour une utilisation en shell.
- **unvault**, **vault**: Chiffrent ou déchiffrent des secrets avec Ansible Vault.
- **to_uuid**: Génère un UUID avec un espace de nom spécifié.

### Manipulation de fichiers et chemins

- **basename**, **win_basename**: Extraient le nom de fichier d'un chemin pour Unix ou Windows.
- **dirname**, **win_dirname**: Extraient le répertoire d'un chemin pour Unix ou Windows.
- **fileglob**: Trouve des fichiers correspondant à un motif de chemin.
- **expanduser**, **expandvars**: Étendent les chemins avec des tildes ou des variables d'environnement.
- **normpath**, **realpath**, **relpath**: Normalisent, résolvent ou relativisent des chemins.
- **path_join**: Joint plusieurs composants de chemin.
- **win_splitdrive**: Sépare la lettre de lecteur dans les chemins Windows.

### Opérations mathématiques et logiques

- **log**, **pow**, **root**: Calculent le logarithme, la puissance ou la racine.
- **random**: Génère un nombre ou un élément aléatoire d'une liste.
- **shuffle**: Mélange aléatoirement les éléments d'une liste.
- **product**: Produit cartésien de listes.
- **ternary**: Opération ternaire, similaire à l'opérateur ? : en programmation.

### Encodage et Hash

- **b64encode**, **b64decode**: Encodent ou décodent une chaîne en Base64.
- **checksum**, **hash**, **md5**, **sha1**: Calculent un checksum ou un hash MD5/SHA-1 des données.
- **password_hash**: Génère un hash de mot de passe.

### Gestion des données temporaires et vérifications

- **mandatory**: Vérifie si une variable est définie et renvoie une erreur si ce n'est pas le cas.
- **type_debug**: Affiche le type Python d'une variable pour aider au débogage.
- **unique**, **union**, **intersect**, **difference**, **symmetric_difference**: Opérations sur les ensembles pour gérer l'unicité, l'union, l'intersection, etc.

### Conversion et formatage de date

- **to_datetime**: Convertit une chaîne en objet datetime.
- **strftime**: Formate une date selon un motif spécifié.

### Gestion des URL

- **urldecode** : Décodent les séquences encodées d'une URL.
- **urlsplit**:  Décomposent une URL en ses composants.

## 2.4. Exemples

```YAML
- name: Collection and display of essential system information
  hosts: localhost
  gather_facts: true
  tasks:
    - name: Show RAM information
      ansible.builtin.debug:
        msg: "{{ ansible_facts.memtotal_mb | regex_replace('^(.*)$', '\\1 MB of RAM') }}"

    - name: Show CPU information
      ansible.builtin.debug:
        msg: "The processor is a {{ ansible_facts.processor[1] }}, with {{ ansible_facts.processor_cores }} cores and {{ ansible_facts.processor_threads_per_core }} threads per core."

    - name: Show available disk space on root partition
      ansible.builtin.debug:
        msg: "Free disk space on the root partition: {{ ansible_facts.mounts | selectattr('mount', 'equalto', '/') | map(attribute='size_available') | first | human_readable }}"
```

#### 1. Informations sur la mémoire vive

- **regex_replace** : Ajoute `' MB of RAM'` à la valeur de la mémoire totale pour clarifier l'unité et le type de l'information.

#### 2. Informations sur le processeur

- Utilise les faits collectés **ansible_facts.processor[1]** pour obtenir la marque du processeur.
- **ansible_facts.processor_cores** et **ansible_facts.processor_threads_per_core** sont utilisés pour afficher le nombre de cœurs et de **threads** par coeur.

#### 3. Espace disque disponible sur la partition racine

- **selectattr('mount', 'equalto', '/')** : Sélectionne les informations de la partition racine (`/`).
- **map(attribute='size_available')** : Extrait l'attribut **size_available** qui représente l'espace disponible.
- **first** : Sélectionne la première entrée, car la racine ne devrait avoir qu'une seule partition listée.
- **human_readable** : Convertit les **bytes** en format lisible, par exemple de **bytes** en **GB**.

```YAML
- name: Example of JSON data processing
  hosts: localhost
  gather_facts: false
  vars:
    json_data: '{"employees": [{"name": "John", "age": 28, "department": "Sales"}, {"name": "Jane", "age": 32, "department": "HR"}, {"name": "Doe", "age": 45, "department": "HR"}]}'
    department: "HR"
  tasks:
    - name: Load and filter JSON data
      ansible.builtin.debug:
        msg: "{{ (json_data | from_json).employees | selectattr('department', 'equalto', department) | map(attribute='name') | join(', ') }}"
```

- **from_json** : Ce filtre convertit une chaîne **JSON** en structure de données **Ansible** (dans ce cas, un dictionnaire). L'expression (**json_data | from_json)** transforme la chaîne **json_data** en un dictionnaire **Ansible**.
- **selectattr('department', 'equalto', department)** : Ce filtre parcourt la liste des employés (extraite avec **.employees** après la conversion du **JSON**) et sélectionne ceux dont l'attribut **department** correspond à la valeur de la variable **department** ("HR" dans cet exemple). **selectattr** est utilisé pour filtrer les éléments d'une liste basée sur la correspondance d'un attribut spécifique.
- **map(attribute='name')** : Après avoir filtré les employés par département, ce filtre est utilisé pour transformer la liste des dictionnaires filtrés en une liste contenant uniquement les noms des employés. **map(attribute='name')** extrait la valeur de l'attribut **name** pour chaque élément de la liste filtrée.
- **join(', ')** : Finalement, ce filtre prend la liste des noms et les joint en une seule chaîne de caractères, avec chaque nom séparé par une virgule et un espace. Cela est utile pour afficher les noms de manière lisible dans le message de débogage.

```YAML
- name: Example of text and list manipulation
  hosts: localhost
  gather_facts: false
  vars:
    list_of_strings: ["example1.txt", "test2.doc", "sample3.pdf", "test4.doc", "demo5.txt"]
    search_pattern: "\\.doc$"
  tasks:
    - name: Filter and manipulate list items
      ansible.builtin.debug:
        msg: "{{ list_of_strings | select('regex', search_pattern) | map('regex_replace', '^(.*)\\..*$', '\\1') }}"
```

- **select('regex', search_pattern)** : Ce filtre parcourt **list_of_strings** et sélectionne les éléments qui correspondent à l'expression régulière spécifiée par **search_pattern**. Dans ce cas, il filtre les chaînes qui se terminent par **.doc**, correspondant à des documents Word.
- **map('regex_replace', '^\(.\*\)\\\\..\*\$', '\\\\1')** : Ce filtre est utilisé pour transformer les éléments filtrés. **regex_replace** modifie chaque chaîne en supprimant l'extension du fichier. L'expression régulière `'^(.*)\\..*$'` capture le nom du fichier sans l'extension, et `'\\1'` est utilisé pour remplacer la chaîne entière par juste le nom capturé. Cela signifie que chaque élément comme "`test2.doc`" sera transformé en "`test2`".
