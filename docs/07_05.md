# 5. Les conditions

## 5.1. Les conditions

Les conditions sont des instructions qui vous permettent d'exécuter différentes tâches ou d'atteindre différents objectifs selon la valeur d'un **fact** (informations sur le système distant), d'une variable, ou le résultat d'une tâche précédente.

Vous pouvez également vouloir que la valeur de certaines variables dépende de celle d'autres variables, ou créer des groupes supplémentaires d'hôtes basés sur d'autres critères.

Tous les filtres et les tests vus précédemment fonctionnement dans les conditions.

## 5.2. Conditions de base avec when

La condition la plus simple s'applique à une seule tâche.

Vous créez la tâche, puis ajoutez une instruction **when** qui applique un test.

La clause **when** prend une expression **Jinja2** sans les doubles accolades.

Lorsque vous exécutez la tâche ou le **playbook**, **Ansible** évalue le test pour tous les hôtes. Sur les hôtes où le test réussit (retourne une valeur de **True**), **Ansible** exécute cette tâche.

```YAML
---
- name: Example Playbook using when with tests and filters
  hosts: localhost
  gather_facts: false
  tasks:
    - name: Conditional execution based on literal value and filter
      ansible.builtin.debug:
        msg: "The value is an odd number"
      when: (3 | int) is odd

    - name: Display a message if the length of a literal string is greater than 5
      ansible.builtin.debug:
        msg: "The chain is quite long"
      when: "'Hello World' | length > 10"

    - name: Run a task if the converted string is equal to a specific word
      ansible.builtin.debug:
        msg: "The string is 'ansible'"
      when: "'Ansible' | lower == 'ansible'"
```

## 5.3. Conditions basées sur des facts

Comme nous l'avions vu, les **facts** sont des attributs des hôtes individuels, incluant l'adresse **IP**, **le système d'exploitation**, l'**état d'un système de fichiers**, et bien plus.

Nous pouvons utiliser les **facts** pour :

- Installer un paquet spécifique seulement quand le système d'exploitation est d'une version particulière.
- Configurer un pare-feu sur les hôtes ayant des adresses IP internes.
- Réaliser des tâches de nettoyage seulement quand un système de fichiers est presque plein.

```YAML
---
- name: Example of managing diverse configurations
  hosts: all
  gather_facts: true

  tasks:
    - name: Updating packages on Ubuntu servers version 24
      ansible.builtin.apt:
        name: '*'
        state: latest
      when:
        - ansible_facts.distribution == "Ubuntu"
        - ansible_facts.distribution_major_version == "24"
    - ansible.builtin.debug:
        msg: "Distri : {{ ansible_facts.distribution }}, Version : {{ ansible_facts.distribution_major_version }}"
```

Notez bien l'utilisation de conditions multiples. Il faut que les deux conditions listées soient vraies (ET logique).

## 5.4. Conditions basées sur des variables

Vous pouvez utiliser des conditions basées sur une ou plusieurs variables, y compris celles définies de manière dynamique avec **register** :

```YAML
---
- name: Example of using conditions with register
  hosts: localhost
  gather_facts: false
  tasks:
    - name: Check if the file exists
      ansible.builtin.command: ls /tmp/my_file.txt
      register: resultat
      ignore_errors: true

    - name: Display a message if the file exists
      ansible.builtin.debug:
        msg: "The file already exists."
      when: resultat.rc == 0

    - name: Create the file if it does not exist
      ansible.builtin.file:
        path: /tmp/my_file.txt
        state: touch
      when: resultat.rc != 0
```

Essayez cet exemple deux fois pour voir le résultat.

## 5.5. Conditions multiples, groupes logiques et opérateurs logiques

Vous pouvez utiliser des listes de conditions, des groupes logiques avec des parenthèses et des opérateurs logiques (comme `or` ou `and`).

```YAML
---
- name: Example with multiple and grouped conditions
  hosts: localhost
  gather_facts: false
  vars:
    status: "active"
    user_role: "admin"
    env: "production"
    num_errors: 5

  tasks:
    - name: Show message to active production administrators
      ansible.builtin.debug:
        msg: "The admin user is active in the production environment."
      when:
        - status == "active"
        - user_role == "admin"
        - env == "production"

    - name: Check if the user is inactive or if there are errors
      ansible.builtin.debug:
        msg: "The user is inactive or there are critical errors."
      when: (status != "active" or num_errors > 3)

    - name: Specific action for test or development environments
      ansible.builtin.debug:
        msg: "Action in development or test environment with less than 5 errors."
      when:
        - env in ["development", "test"]
        - num_errors < 5

    - name: Run a task for a non-production environment without admin
      ansible.builtin.debug:
        msg: "Non-production environment and user is not an admin."
      when:
        - env != "production"
        - user_role != "admin"

    - name: Check multiple grouped conditions
      ansible.builtin.debug:
        msg: "Complex conditions with grouping."
      when: >
        (env == "production" or env == "staging")
        and (user_role == "admin" and num_errors <= 2)
```

1. **Condition pour les administrateurs actifs en production** : utilise trois conditions simples qui doivent toutes être vraies pour exécuter la tâche. Toutes les variables doivent correspondre aux valeurs spécifiées.
2. **Vérification de l'inactivité ou des erreurs** : utilise les parenthèses pour grouper les conditions avec l'opérateur `or`, ce qui signifie que la tâche s'exécute si l'une des conditions est vraie.
3. **Action pour les environnements de développement ou de test** : comprend une condition qui vérifie si la variable **environment** est soit **development** soit **test**, et une autre condition qui vérifie que le nombre d'erreurs est inférieur à 5.
4. **Tâche pour environnement non production sans admin** : utilise des conditions pour vérifier que l'environnement n'est pas de **production** et que l'utilisateur n'est pas un administrateur.
5. **Conditions multiples groupées** : utilise une condition complexe avec un groupement logique où **environment** doit être soit **production** soit **staging**, et simultanément **user_role** doit être **admin** avec un **nombre d'erreurs <= 2**. Cette condition est écrite sur une seule ligne avec `>` pour plus de clarté.

_Note_ : avec **YAML**, **>** est utilisé pour indiquer le début d'un bloc de texte plié (**folded block**). **_Ce type de bloc permet d'écrire un texte sur plusieurs lignes, mais il sera interprété comme une seule ligne continue_**, ce qui est particulièrement utile pour les expressions longues ou les chaînes de caractères.

Quand vous utilisez **>**, toutes les lignes qui suivent sont combinées en une seule ligne, avec un espace inséré là où il y avait un saut de ligne. Cela vous permet d'écrire une condition complexe de manière plus organisée et lisible, tout en assurant que **YAML** et **Ansible** l'interprètent comme une expression continue sur une seule ligne.
