# 4. Gestion des erreurs

## 4.1. Gestion des erreurs dans les playbooks

**Ansible** fournit divers outils et paramètres pour gérer les erreurs lors de l'exécution des **playbooks**.

Lorsque qu'**Ansible** reçoit un code de retour non nul d'une commande ou une erreur d'un module, par défaut, il arrête l'exécution sur cet hôte et continue sur les autres hôtes.

Cependant, dans certaines circonstances, vous pouvez vouloir un comportement différent. Voici comment configurer **Ansible** pour gérer les erreurs selon vos besoins.

### 4.1.1. Ignorer les commandes échouées

Par défaut, **Ansible** arrête l'exécution des tâches sur un hôte lorsqu'une tâche échoue. Vous pouvez utiliser **ignore_errors** pour continuer malgré l'échec.

```YAML
- name: Do not consider this a failure
  ansible.builtin.command: /bin/false
  ignore_errors: true
```

Cette directive permet à **Ansible** de continuer l'exécution des tâches suivantes même si la commande précédente échoue. Cela peut être utile lorsque certaines commandes peuvent échouer sans impact significatif sur le reste du processus.

### 4.1.2. Ignorer les erreurs d'hôtes inaccessibles

Vous pouvez ignorer les erreurs dues à des hôtes inaccessibles avec le mot-clé **ignore_unreachable**.

**Ansible** ignore les erreurs de tâche mais continue d'exécuter les tâches futures sur l'hôte inaccessible.

```YAML
- name: This task is executed, fails, and the failure is ignored.
  ansible.builtin.command: /bin/true
  ignore_unreachable: true
```

Vous pouvez également appliquer ce paramètre au niveau du **playbook** :

```YAML
- hosts: all
  ignore_unreachable: true
  tasks:
```

### 4.1.3. Réinitialisation des hôtes inaccessibles

Si **Ansible** ne peut pas se connecter à un hôte, il marque cet hôte comme "**UNREACHABLE**" et le retire de la liste des hôtes actifs pour l'exécution.

Vous pouvez réactiver tous les hôtes avec **meta: clear_host_errors** pour que les tâches suivantes puissent essayer de les atteindre à nouveau.

```YAML
- name: Reset inaccessible host errors
  meta: clear_host_errors
```

## 4.2. Définir les conditions d'échec

**Ansible** permet de définir ce que signifie "échec" pour chaque tâche à l'aide de la condition **failed_when**.

Par exemple, vous pouvez vérifier un mot ou une phrase dans la sortie d'une commande ou baser l'échec sur le code de retour.

```YAML
- name: The task failed when the command output contains 'FAILED'
  ansible.builtin.command: /usr/bin/example-command -x -y -z
  register: command_result
  failed_when: "'FAILED' in command_result.stderr"
```

Vous pouvez aussi combiner plusieurs conditions d'échec :

```YAML
- name: Check if a file exists in /tmp and fail if it does.
  ansible.builtin.command: ls /tmp/this_should_not_be_here
  register: result
  failed_when:
    - result.rc == 0
    - '"No such" not in result.stdout'
```

## 4.3. Définir les conditions de "changement"

Vous pouvez également définir quand une tâche a "changé" un nœud distant avec la condition **changed_when**.

Cela permet de déterminer, en fonction des codes de retour ou de la sortie, si un changement doit être rapporté dans les statistiques d'**Ansible** et si un **handler** doit être déclenché (_nous les verrons dans le chapitre suivant_).

```YAML
- name: Report 'changed' when the return code is not equal to 2
  ansible.builtin.shell: /usr/bin/commande
  register: un_resultat
  changed_when: "un_resultat.rc != 2"
```

## 4.4. Abandonner un play sur tous les hôtes

Parfois, vous souhaitez qu'une erreur sur un seul hôte ou un certain pourcentage d'hôtes arrête l'exécution du **play** sur tous les hôtes.

Vous pouvez arrêter l'exécution après la première erreur avec **any_errors_fatal** ou définir un pourcentage maximum d'échecs avec **max_fail_percentage**.

```YAML
- hosts: all
  any_errors_fatal: true
```

Et : 

```YAML
- hosts: webservers
  max_fail_percentage: 30
```

## 4.5. Exemples

Voici un exemple réaliste :

```YAML
- name: Web and database service management
  hosts: all
  become: yes
  tasks:
    - name: Update APT packages
      ansible.builtin.apt:
        update_cache: yes

    - name: Install NGINX on web servers
      ansible.builtin.apt:
        name: nginx
        state: latest
      when: "'webservers' in group_names"
      ignore_errors: true

    - name: Start NGINX
      ansible.builtin.service:
        name: nginx
        state: started
      when: "'webservers' in group_names"

    - name: Check the accessibility of web servers
      ansible.builtin.uri:
        url: http://localhost
        status_code: 200
      when: "'webservers' in group_names"
      register: web_status
      failed_when: web_status.status != 200

    - name: Check the status of PostgreSQL
      ansible.builtin.shell: pg_isready
      when: "'dbservers' in group_names"
      register: pgsql_status
      failed_when: pgsql_status.rc != 0
      changed_when: pgsql_status.rc == 0
```

**ignore_errors: true** permet à **Ansible** de continuer l'exécution des autres tâches même si cette tâche échoue. Cela peut être utile si, par exemple, l'installation de **NGINX** échoue sur un serveur, mais que vous voulez quand même continuer à exécuter le reste du **playbook**.

**failed_when: web_status.status != 200** signifie que cette tâche échouera si le code de statut **HTTP** retourné n'est pas **200**, indiquant que le serveur web n'est pas accessible comme prévu.

**register: pgsql_ready_status** enregistre le résultat de la vérification de l'état de PostgreSQL.

**failed_when: pgsql_ready_status.rc != 0** indique que cette tâche échouera si **PostgreSQL** n'est pas prêt.

**changed_when: pgsql_ready_status.rc == 0** indique que cette tâche sera marquée comme ayant modifié le système si **PostgreSQL** est prêt.

En supposant que nous ayons par exemple l'inventaire suivant :

```YAML
all:
  children:
    webservers:
      hosts:
        web1:
          ansible_host: 64.226.79.72
    dbservers:
      hosts:
        db1:
          ansible_host: 164.92.178.187
```