# 6. Les modules shell et command

## 6.1. Le module command

### 6.1.1. Synposis

Le module `ansible.builtin.command` permet d'exécuter des commandes sur des nodes cibles.

Ce module est simple d'utilisation et ne traite pas la commande à travers un **shell**, ce qui signifie qu'il n'interprète pas les variables de **shell** ou les métacaractères **shell** comme **\***, **<**, **>**, **|**, **&**, etc.

Ainsi, lorsque vous utilisez le module **command**, **Ansible** crée un nouveau processus sur le système cible pour exécuter la commande spécifiée.

Ce processus est lancé directement par le système d'exploitation sous-jacent sans l'intermédiation d'un **shell** comme **bash** ou **sh**. Cela signifie qu'aucun interpréteur de commandes n'est utilisé pour analyser ou exécuter la commande.

Le système d'exploitation sur l'hôte cible reçoit la commande à exécuter comme un appel système, typiquement via des fonctions comme **execve** sous **Linux**.

_Pour les opérations nécessitant ces caractéristiques, il faut utiliser le module `ansible.builtin.shell`._

### 6.1.2. Paramètres

- **cmd**: spécifie la commande à exécuter. Peut être accompagné d'options ou de chemins.
- **argv**: liste d'arguments pour la commande, utile pour passer des arguments avec des espaces.
- **chdir**: change le répertoire courant sur la node cible avant d'exécuter la commande.
- **creates**: un chemin de fichier ou un motif glob. Si ce fichier existe déjà, la commande ne s'exécutera pas.
- **removes**: inverse de **creates**. La commande s'exécute uniquement si le fichier spécifié n'existe pas.
- **stdin**: permet de définir directement l'entrée standard de la commande.
- **stdin_add_newline**: ajoute un retour à la ligne à l'entrée standard si défini à **true**.
- **strip_empty_ends**: supprime les lignes vides de la fin de **stdout** ou **stderr**.

### 6.1.3. Valeurs de retour

Lorsque vous utilisez le module `ansible.builtin.command`, il exécute les commandes spécifiées et renvoie une série de valeurs qui peuvent être très utiles pour le débogage, le contrôle d'état et les actions conditionnelles.

#### cmd

- Type : `list / elements=string`
- Description : Cette clé contient la commande exacte qui a été exécutée par la tâche.
- Retourné : Toujours
- Exemple : `["echo", "hello"]`

#### delta

- Type : `string`
- Description : Temps écoulé pour l'exécution de la commande, indiquant combien de temps la commande a pris pour s'exécuter du début à la fin.
- Retourné : Toujours
- Exemple : `"0:00:00.001529"`

#### end

- Type : `string`
- Description : Heure de fin de l'exécution de la commande.
- Retourné : Toujours
- Exemple : `"2017-09-29 22:03:48.084657"`

#### msg

- Type : `boolean`
- Description : Indique si la tâche a entraîné un changement ou non. `True` signifie qu'il y a eu un changement.
- Retourné : Toujours
- Exemple : `true`

#### rc (Return Code)

- Type : `integer`
- Description : Code de retour de la commande. Un code `0` signifie que la commande a réussi sans erreurs.
- Retourné : Toujours
- Exemple : `0`

#### start

- Type : `string`
- Description : Heure de début de l'exécution de la commande.
- Retourné : Toujours
- Exemple : `"2017-09-29 22:03:48.083128"`

#### stderr

- Type : `string`
- Description : Sortie d'erreur standard de la commande si elle génère des erreurs.
- Retourné : Toujours
- Exemple : `"ls cannot access foo: No such file or directory"`

#### stderr_lines

- Type : `list / elements=string`
- Description : La sortie d'erreur standard divisée en lignes.
- Retourné : Toujours
- Exemple : `["ls cannot access foo: No such file or directory", "ls \u2026"]`

#### stdout

- Type : `string`
- Description : Sortie standard de la commande exécutée.
- Retourné : Toujours
- Exemple : `"Clustering node rabbit@slave1 with rabbit@master \u2026"`

#### stdout_lines

- Type : `list / elements=string`
- Description : La sortie standard de la commande divisée en lignes.
- Retourné : Toujours
- Exemple : `["Clustering node rabbit@slave1 with rabbit@master \u2026"]`

Voici un exemple de sortie :

```YAML
- hosts: localhost
  tasks:
    - name: Check the disk used on the server
      ansible.builtin.command: df -h
      register: sortie

    - name: Show output of df -h command
      ansible.builtin.debug:
        var: sortie
```

_Nous verrons **register** en détail dans le chapitre sur les variables. Sachez simplement que nous enregistrons le retour de la commande dans une variable pour l'utiliser ensuite._

```SHELL
ok: [localhost] => {
    "sortie": {
        "changed": true,
        "cmd": [
            "df",
            "-h"
        ],
        "delta": "0:00:00.008016",
        "end": "2024-05-06 14:46:00.484816",
        "failed": false,
        "msg": "",
        "rc": 0,
        "start": "2024-05-06 14:46:00.476800",
        "stderr": "",
        "stderr_lines": [],
        "stdout": "Filesystem      Size  Used Avail Use% Mounted on\ntmpfs            46M 1016K   45M   3% /run\n/dev/vda1       8.7G  2.8G  6.0G  32% /\ntmpfs           230M  140K  230M   1% /dev/shm\ntmpfs           5.0M     0  5.0M   0% /run/lock\n/dev/vda16      881M   61M  758M   8% /boot\n/dev/vda15      105M  6.1M   99M   6% /boot/efi\ntmpfs            46M   12K   46M   1% /run/user/0",
        "stdout_lines": [
            "Filesystem      Size  Used Avail Use% Mounted on",
            "tmpfs            46M 1016K   45M   3% /run",
            "/dev/vda1       8.7G  2.8G  6.0G  32% /",
            "tmpfs           230M  140K  230M   1% /dev/shm",
            "tmpfs           5.0M     0  5.0M   0% /run/lock",
            "/dev/vda16      881M   61M  758M   8% /boot",
            "/dev/vda15      105M  6.1M   99M   6% /boot/efi",
            "tmpfs            46M   12K   46M   1% /run/user/0"
        ]
    }
}
```

### 6.1.4. Exemples

#### Exécution simple d'une commande

```YAML
- hosts: localhost
  tasks:
    - name: Check the disk used on the server
      ansible.builtin.command: df -h
      register: disk_used

    - name: Show output of df -h command
      ansible.builtin.debug:
        msg: "{{ disk_used.stdout_lines }}"
```

#### Utiliser chdir pour changer de répertoire avant exécution

```YAML
- name: List files in a specific directory
  ansible.builtin.command:
    cmd: ls -l
    chdir: /var/log
```

#### Utilisation conditionnelle avec creates

```YAML
- name: Create a database if it does not exist
  ansible.builtin.command:
    cmd: /usr/bin/make_database.sh db_user db_name
    creates: /path/to/database
```

#### Passer des arguments avec argv pour gérer les espaces

```YAML
- name: Run a script with complex arguments
  ansible.builtin.command:
    argv:
      - /path/to/script.sh
      - "argument with spaces"
      - "--option=another option"
```

#### Utilisation conditionnelle avec removes

```YAML
- name: Generate a report only if it does not exist
    ansible.builtin.command:
      cmd: /usr/local/bin/generate_report.sh
      removes: /path/to/report.pdf
```

### 6.1.5. Utilisation de args

Vous pouvez également utiliser cette syntaxe alternative :

```YAML
---
- name: Example of use with args
  hosts: all
  tasks:
    - name: Create a temporary file
      ansible.builtin.command: touch /tmp/temp_file.txt
      args:
        creates: /tmp/temp_file.txt

    - name: Delete a temporary file if another specified file does not exist
      ansible.builtin.command: rm /tmp/temp_file.txt
      args:
        removes: /tmp/condition.txt
```

## 6.2. Le modules shell

### 6.2.1. Synopsis

Le module `ansible.builtin.shell` permet d'exécuter des commandes **shell** sur des nodes distantes.

Ce module fonctionne presque de la même manière que le module `ansible.builtin.command`, à l'exception notable qu'il exécute les commandes à travers un interpréteur de commandes (**/bin/sh**) sur la node distante.

### 6.2.2. Paramètres

- **chdir**: changez de répertoire avant d'exécuter la commande.
- **cmd**: commande à exécuter, suivie d'arguments optionnels.
- **creates**: ne pas exécuter la commande si ce fichier existe déjà.
- **executable**: modifiez l'interpréteur de commandes utilisé pour exécuter la commande. exige un chemin absolu.
- **free_form**: permet de saisir librement la commande à exécuter.
- **removes**: exécutez la commande seulement si ce fichier n'existe pas.
- **stdin**: définissez l'entrée standard de la commande directement avec la valeur spécifiée.
- **stdin_add_newline**: ajoute une nouvelle ligne aux données de l'entrée standard si défini à `true`.

## 6.3. Exemples

Chacun de ces exemples utilise des caractéristiques qui nécessitent un interpréteur de commandes pour fonctionner correctement, comme la logique conditionnelle avec **if** ou l'utilisation de pipes et de redirections.

```YAML
- name: Executing a chain of commands with conditional logic
  ansible.builtin.shell: |
    mkdir -p /path/to/directory && cd /path/to/directory && wget http://example.com/file.txt

- name: Using Output Redirection and Pipes
  ansible.builtin.shell: grep 'pattern' /path/to/file | sort > /path/to/sorted_file

- name: Run a command using a specific environment variable
  ansible.builtin.shell: echo $MYVAR
  environment:
    MYVAR: "Hello World"

- name: Use Bash-specific features
  ansible.builtin.shell: |
    if [[ $(hostname) =~ "dev" ]]; then
      echo "This is a dev server.";
    fi
  args:
    executable: /bin/bash
```

## 6.4. Quand utiliser shell vs command

### 6.4.1. Utilisation de ansible.builtin.command

Le module `ansible.builtin.command` est utilisé pour exécuter des commandes simples sur des hôtes distants sans qu'il n'y ait besoin de fonctionnalités d'interpréteur de commandes, telles que les redirections ou l'exécution de plusieurs commandes en une seule ligne.

Ce module ne traite pas la commande via un **shell**, ce qui signifie que des éléments tels que les variables d'environnement (**$HOME**), les caractères spéciaux (**\***, **?**, **<**, **>**, **|**, **;**, **&**) ou l'utilisation de contrôles de flux logiques (**&&**, **||**) ne fonctionneront pas.

### 6.4.2. Utilisation de ansible.builtin.shell

Le module `ansible.builtin.shell` est utilisé lorsque vous avez besoin de fonctionnalités spécifiques au **shell** pour exécuter la commande. Cela inclut l'utilisation de tubes (**|**), de redirections (**>**, **>>**, **<**), d'expansions de joker (**\***), et d'autres opérations qui sont traitées par l'interpréteur de commandes comme **bash** ou **sh**.

Ce module doit être utilisé avec prudence car il est plus sujet aux injections de code si les entrées ne sont pas correctement nettoyées ou citées.

Il est donc recommandé d'utiliser le module **command** dans tous les cas où c'est possible (donc lorsqu'une fonctionnalité de **shell** n'est pas indispensable).
