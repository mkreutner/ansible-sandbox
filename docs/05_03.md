# 3. Le module copy

## 3.1. Autre exemple : le module copy

Le module `ansible.builtin.copy` est utilisé pour copier des fichiers ou des structures de répertoires de la machine locale ou distante vers un emplacement sur la machine distante. Il permet également de définir des métadonnées du système de fichiers telles que les permissions, la propriété, etc., même lorsque le fichier ou le répertoire existe déjà sur le système cible. Certaines de ces métadonnées peuvent également être copiées à la demande.

## 3.2. Fonctionnalités principales

- **Copie de fichiers/dossiers** : permet de copier des fichiers ou des répertoires de la machine de contrôle à des emplacements distants.
- **Gestion des métadonnées**: possibilité de définir ou de conserver les permissions, le propriétaire, et les attributs des fichiers ou dossiers copiés.
- **Validation de fichier** : permet d'utiliser une commande de validation pour s'assurer que les fichiers copiés sont corrects avant de remplacer les fichiers cibles.
- **Support SELinux** : peut gérer les contextes **SELinux** pour les fichiers copiés.

## 3.3. Paramètres

Aucun intérêt de connaitre tous les paramètres d'un module ! Cet exemple est pour montrer que les possibilités sont vraiment extrêmement vastes pour chaque module et que vous pouvez généralement tout faire avec les modules **Ansible** : il suffit de lire la documentation.

- **attributes (string)**: définit les attributs du fichier ou répertoire cible, similaire à l'utilisation de **chattr** sur un système Linux.
- **backup (boolean)**: crée un fichier de sauvegarde du fichier cible avant de le modifier, permettant la restauration en cas d'erreur.
- **checksum (string)**: spécifie le checksum SHA1 du fichier source pour validation, afin de s'assurer que le transfert du fichier est correct.
- **content (string)**: permet de définir le contenu du fichier directement, utile pour créer des fichiers avec un contenu spécifique sans avoir à transférer un fichier.
- **decrypt (boolean)**: contrôle la décryptage automatique des fichiers source chiffrés avec **Ansible Vault**.
- **dest (path, requis)**: le chemin absolu sur la machine distante où le fichier doit être copié.
- **directory_mode (any)**: permet de définir les permissions des répertoires nouvellement créés lors de la copie récursive.
- **follow (boolean)**: indique si les liens symboliques au niveau du système de fichiers de destination doivent être suivis.
- **force (boolean)**: force la copie du fichier même si le contenu du fichier destination est identique.
- **group (string)**: le nom du groupe qui devrait être propriétaire du fichier ou répertoire cible.
- **local_follow (boolean)**: indique si les liens symboliques dans l'arborescence source locale doivent être suivis.
- **mode (any)**: définit les permissions du fichier ou du répertoire cible, avec la possibilité d'utiliser des modes symboliques ou octaux.
- **owner (string)**: le nom de l'utilisateur qui devrait être propriétaire du fichier ou répertoire cible.
- **remote_src (boolean)**: Indique si la source src est sur le système de fichiers local ou distant.
- **selevel (string)**: spécifie le niveau SELinux du fichier ou du répertoire cible.
- **serole (string)**: définit le rôle SELinux du fichier ou du répertoire cible.
- **setype (string)**: définit le type SELinux du fichier ou du répertoire cible.
- **seuser (string)**: définit l'utilisateur SELinux du fichier ou du répertoire cible.
- **src (path)**: le chemin du fichier local à copier sur la machine distante.
- **unsafe_writes (boolean)**: permet d'effectuer des écritures non atomiques sur les systèmes de fichiers qui ne supportent pas les opérations atomiques.
- **validate (string)**: commande pour valider le fichier avant de le copier, généralement utilisé pour des fichiers de configuration critiques.

## 3.4. Exemples

**Copie simple** : copie d'un fichier de configuration local vers un serveur distant avec des permissions spécifiques.

```YAML
- name: Copy configuration file
  ansible.builtin.copy:
    src: /path/to/local/foo.conf
    dest: /path/to/remote/foo.conf
    owner: root
    group: root
    mode: '0644'
```

**Utilisation de contenu en ligne** : création d'un fichier sur un hôte distant en utilisant du contenu défini directement dans le **playbook**.

```YAML
- name: Create file with specified content
  ansible.builtin.copy:
    content: |
      Hello, World!
    dest: /path/to/remote/file.txt
```

**Validation avec backup** : copie un fichier tout en validant son intégrité et en créant un **backup** de l'ancien fichier.

```YAML
- name: Copy sudoers file with validating content and backup previous version
  ansible.builtin.copy:
    src: /mine/sudoers
    dest: /etc/sudoers
    validate: /usr/sbin/visudo -csf %s
    backup: yes
```

## 3.5. Détection des changements

Le module est conçu pour être efficient lors de la gestion des fichiers à copier sur des systèmes distants. L'un des aspects clés de ce module est sa capacité à éviter de recopier un fichier si celui-ci n'a pas changé par rapport à la version qui se trouve déjà sur la machine distante.

Avant de copier un fichier, **Ansible** calcule le **checksum** du fichier source sur le noeud de contrôle (la machine où s'exécute **Ansible**).

Si le paramètre **checksum** est spécifié, il utilise cette valeur comme référence.

Une fois le **checksum** calculé, **Ansible** tente de récupérer le **checksum** du fichier cible sur la machine distante.

Si le fichier cible existe déjà, **Ansible** compare les deux **checksums**.

Si les **checksums** correspondent, cela signifie que le fichier n'a pas été modifié depuis la dernière copie.

Dans ce cas, **Ansible** sait que le contenu du fichier est identique et décide de ne pas recopier le fichier.

En utilisant cette méthode de comparaison de **checksums**, **Ansible** évite les transferts de fichiers inutiles, ce qui réduit la charge sur le réseau et accélère le processus de déploiement.

**Prenons un exemple** :

1. **Créez le fichier `hello.txt` sur la node de contrôle** :

```SHELL
echo "Bonjour !" > hello.txt
```

2. **Copiez le fichier** :

```SHELL
ansible all -m copy -a "src=/root/ansible/hello.txt dest=/root/hello.txt" -i inventory.yml
```

**Vous obtenez** :

```SHELL
node1 | CHANGED => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "changed": true,
    "checksum": "72181c553b9223c52597e4af1bccd6721a177fa6",
    "dest": "/root/hello.txt",
    "gid": 0,
    "group": "root",
    "md5sum": "b31f5615577d5a843fff02855b4c8cbd",
    "mode": "0644",
    "owner": "root",
    "size": 10,
    "src": "/root/.ansible/tmp/ansible-tmp-1714839888.0954347-36146-275149485968069/source",
    "state": "file",
    "uid": 0
}
```

**Notez bien le `checksum` et le `changed: true`**.

**Si vous refaites la commande (2. Copiez le fichier), vous aurez** :

```SHELL
node1 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "changed": false,
    "checksum": "72181c553b9223c52597e4af1bccd6721a177fa6",
    "dest": "/root/hello.txt",
    "gid": 0,
    "group": "root",
    "mode": "0644",
    "owner": "root",
    "path": "/root/hello.txt",
    "size": 10,
    "state": "file",
    "uid": 0
}
```

**Notez bien que `le checksum` est identique et le `changed: false`. Le fichier n'a pas été copié.**
