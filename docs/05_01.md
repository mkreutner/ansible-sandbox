# 1. Les modules en détail

## 1.1. Les modules

Comme nous l'avons vu, les modules peuvent être exécutés en ligne de commande avec l'option **-m** ou dans les tâches des **playbooks**.

Il y a plus de [6000 modules](https://docs.ansible.com/ansible/latest/collections/index_module.html) disponibles sur **ansible**.

Voici quelques catégories (la liste n'est pas exhaustive) :

- **Modules Cloud** (`amazon.aws`, `azure.azcollection`, `google.cloud`, etc.) : ces modules facilitent la gestion des ressources **cloud**, permettant aux utilisateurs d'automatiser la création, la modification, et la gestion des instances, des réseaux, des disques de stockage, des politiques de sécurité, et plus encore sur des plateformes comme **Amazon AWS**, **Microsoft Azure**, et **Google Cloud Platform**.
- **Modules de gestion système** (`ansible.builtin`, `ansible.netcommon`, `ansible.posix`, `ansible.windows`) : ces collections incluent des modules fondamentaux pour la gestion des systèmes d'exploitation **Linux/Unix** et **Windows**. Ils couvrent la manipulation de fichiers, l'exécution de commandes, la gestion des services systèmes, et la configuration réseau basique.
- **Modules pour équipements réseau** (`cisco.*`, `arista.eos`, `junipernetworks.junos`, etc.) : conçus spécifiquement pour automatiser la configuration et la gestion d'équipements réseau de fabricants comme **Cisco**, **Arista**, et **Juniper**. Ils permettent de gérer la configuration des routes, des **VLANs**, des **ACLs**, et d'autres aspects réseaux critiques.
- **Modules communautaires** (`community.aws`, `community.mysql`, `community.rabbitmq`, etc.) : ces modules étendent les capacités d'Ansible à des services et des technologies spécifiques, tels que des bases de données **MySQL**, des serveurs de message **RabbitMQ**, et des ressources **AWS** qui ne sont pas couvertes par les modules principaux d'**Ansible**.
- **Modules de sécurité et de stockage** (`cyberark.pas`, `f5networks.f5_modules`, `netapp`., etc.) : ces modules permettent la gestion sécurisée et automatisée des configurations de dispositifs de réseau et de stockage, incluant les dispositifs de réseau **F5**, et les solutions de stockage **NetApp** et **PureStorage**.
- **Modules de virtualisation** (`vmware.vmware_rest`, `ovirt.ovirt`, `community.libvirt`) : ils permettent la gestion des plateformes de virtualisation comme **VMware**, **oVirt**, et **KVM** via **libvirt**, facilitant la création, la gestion, et l'automatisation des machines virtuelles et de leurs ressources associées.
- **Modules pour systèmes de fichiers et bases de données** (`community.mysql`, `community.postgresql`, `netapp.ontap`) : ces modules aident à la gestion des systèmes de fichiers et des bases de données, offrant des outils pour la création, la modification, la sauvegarde, et la restauration de bases de données **MySQL** et **PostgreSQL**, ainsi que la gestion des systèmes de fichiers **NetApp**.
- **Modules pour infrastructures spécifiques** (`hetzner.hcloud`, `ngine_io.exoscale`, `vultr.cloud`) : ces modules sont dédiés à la gestion d'infrastructures spécifiques chez des fournisseurs de cloud moins courants, permettant la gestion de ressources dans ces environnements.
- **Modules de gestion de contenu et collaboration** (c`ommunity.zabbix`, `sensu.sensu_go`, `theforeman.foreman`) : ils supportent l'automatisation de la gestion de systèmes de surveillance comme **Zabbix** et **Sensu**, ou des systèmes de gestion d'infrastructure comme **Foreman**.

## 1.2. Fonctionnement de l'exécution des modules

**Ansible** utilise une méthode de communication et d'exécution sans agent pour gérer les nodes distantes.

Cela signifie qu'il n'a pas besoin d'un agent permanent installé sur les nodes distantes pour exécuter des commandes ou des scripts.

Voici comment fonctionne plus en détail **Ansible** :

1. **Établissement de la connexion** :  Ansible initie une connexion **SSH** depuis la machine de contrôle vers la node distante. Il utilise les authentifications par clé **SSH**, ou mot de passe.
2. **Transfert des modules compressés** : les modules requis par les tâches dans le **playbook** sont transférés via la connexion **SSH** établie vers le répertoire temporaire sur la node distantes. Généralement dans `.ansible/tmp`. Les fichiers temporaires sont généralement des scripts **Python** ou des commandes **shell** encapsulées, avec des noms générés aléatoirement pour éviter les conflits. Ces script incluent non seulement le code du module lui-même mais aussi toutes les dépendances nécessaires pour que le module puisse s'exécuter correctement.  Le **script** et ses dépendances sont ensuite compressés en un seul fichier zippé, formaté en **Python**. Ce fichier compressé est ce que l'on appelle un fichier "**AnsiballZ**".
3. **Décompression et exécution des modules** : une fois les modules transférés, **Ansible** exécute ces modules, après les avoir décompressés, directement sur la node distante. Les modules exécutent les tâches spécifiées et renvoient leurs résultats à la machine de contrôle.
4. **Nettoyage** : après l'exécution, **Ansible** supprime les fichiers temporaires créés sur la node distante pour éviter l'encombrement et les problèmes de sécurité.

## 1.3. Exemple pour bien comprendre

### 1.3.1. Création d'un playbook

Créez un fichier `verifier_version_python.yml` avec le contenu suivant :

```YAML
- name: Check Python version
  hosts: all
  tasks:
    - name: Checking Python version
      ansible.builtin.command: python3 --version
      register: version_python
      changed_when: false

    - name: Display Python version
      ansible.builtin.debug:
        msg: "The Python version is {{ version_python.stdout }}"
```

### 1.3.2. Exécuter le playbook avec conservation des fichiers temporaires

Pour exécuter le **playbook** en conservant les fichiers temporaires sur les nodes distantes, vous pouvez utiliser la variable d'environnement `ANSIBLE_KEEP_REMOTE_FILES` lors du lancement du **playbook**.

Voici la commande pour lancer le **playbook** :

```SHELL
ANSIBLE_KEEP_REMOTE_FILES=1 ansible-playbook -i inventaire.yml verifier_version_python.yml
```

Dans cette commande, `ANSIBLE_KEEP_REMOTE_FILES=1` indique à **Ansible** de garder les fichiers temporaires créés lors de l'exécution du **playbook**.

### 1.3.3. Accès aux fichiers temporaires

Après avoir exécuté le **playbook**, connectez-vous à la node distante et et naviguez jusqu'au répertoire temporaire où **Ansible** stocke ses fichiers.

Ce répertoire est généralement situé sous `/home/<utilisateur>/.ansible/tmp/`, mais cela peut varier en fonction de la configuration du système distant.

Vous pouvez aussi les afficher avec **ansible** :

```SHELL
ansible all -m shell -a "ls /root/.ansible/tmp/*" -i inventory.yml
```

- **ansible** : c'est la commande de base pour exécuter des tâches **ad-hoc**.
- **all** : spécifie que la commande doit être exécutée sur tous les hôtes définis dans l'inventaire. Vous pouvez remplacer **all** par un groupe spécifique ou un hôte unique si nécessaire.
- **-m shell** : indique que le module **shell** est utilisé pour exécuter des commandes **shell** directement. Ce module est plus approprié pour des commandes qui nécessitent des fonctionnalités shell, comme les redirections ou les pipes.
- **-a "ls/root/.ansible/tmp/"** : l'argument **-a** est utilisé pour passer les paramètres spécifiques à la commande que le module doit exécuter. Ici, il s'agit de **ls** pour afficher le contenu du dossier dans le répertoire temporaire.
- **-i inventory.yml** : spécifie le fichier d'inventaire à utiliser. Remplacez `inventory.yml` par le chemin vers votre fichier d'inventaire si celui-ci est différent.

Vous aurez pour chaque node :

```SHELL
/root/.ansible/tmp/ansible-tmp-1714837072.622526-34921-158653299174205:
AnsiballZ_setup.py

/root/.ansible/tmp/ansible-tmp-1714837074.833369-34973-236305874594835:
AnsiballZ_command.py

/root/.ansible/tmp/ansible-tmp-1714837090.0181375-35019-95787856286115:
AnsiballZ_setup.py

/root/.ansible/tmp/ansible-tmp-1714837091.9777088-35058-182706832501727:
AnsiballZ_command.py

/root/.ansible/tmp/ansible-tmp-1714837227.4185047-35367-85582429863588:
AnsiballZ_command.py
```

"**AnsiballZ**" est un mécanisme utilisé par **Ansible** pour assembler les modules et leurs dépendances en un seul fichier exécutable **Python** zippé, ce qui simplifie le transfert sur les systèmes distants.

**AnsiballZ_setup.py** : utilisé par le module **setup** d'**Ansible**, qui collecte des données de configuration et des informations sur le système d'exploitation de la machine distante. Ce module est souvent appelé implicitement par **Ansible** pour recueillir les "**facts**" avant d'exécuter les tâches qui en dépendent.

**AnsiballZ_command.py** : utilisé par le module **command** d'**Ansible** pour exécuter des commandes **shell** simples sur des hôtes distants sans interaction avec le **shell** lui-même (c.-à-d., sans traitement des redirections, des pipes, etc.).

Comme le contenu est zippé il n'est pas lisible, sauf la partie pour décompresser et exécuter le script :

```Python
# Note: temp_path isn't needed once we switch to zipimport
    def invoke_module(modlib_path, temp_path, json_params):
        # When installed via setuptools (including python setup.py install),
        # ansible may be installed with an easy-install.pth file.  That file
        # may load the system-wide install of ansible rather than the one in
        # the module.  sitecustomize is the only way to override that setting.
        z = zipfile.ZipFile(modlib_path, mode='a')

        # py3: modlib_path will be text, py2: it's bytes.  Need bytes at the end
        sitecustomize = u'import sys\nsys.path.insert(0,"%s")\n' % modlib_path
        sitecustomize = sitecustomize.encode('utf-8')
        # Use a ZipInfo to work around zipfile limitation on hosts with
        # clocks set to a pre-1980 year (for instance, Raspberry Pi)
        zinfo = zipfile.ZipInfo()
        zinfo.filename = 'sitecustomize.py'
        zinfo.date_time = (2024, 5, 4, 15, 37, 53)
        z.writestr(zinfo, sitecustomize)
        z.close()

        # Put the zipped up module_utils we got from the controller first in the python path so that we
        # can monkeypatch the right basic
        sys.path.insert(0, modlib_path)

        # Monkeypatch the parameters into basic
        from ansible.module_utils import basic
        basic._ANSIBLE_ARGS = json_params

        # Run the module!  By importing it as '__main__', it thinks it is executing as a script
        runpy.run_module(mod_name='ansible.modules.setup', init_globals=dict(_module_fqn='ansible.modules.setup', _modlib_path=modlib_path),
                         run_name='__main__', alter_sys=True)

        # Ansible modules must exit themselves
        print('{"msg": "New-style module did not handle its own exit", "failed": true}')
        sys.exit(1)

    def debug(command, zipped_mod, json_params):
        # The code here normally doesn't run.  It's only used for debugging on the
        # remote machine.
        #
        # The subcommands in this function make it easier to debug ansiballz
        # modules.  Here's the basic steps:
        #
        # Run ansible with the environment variable: ANSIBLE_KEEP_REMOTE_FILES=1 and -vvv
        # to save the module file remotely::
        #   $ ANSIBLE_KEEP_REMOTE_FILES=1 ansible host1 -m ping -a 'data=october' -vvv
        #
        # Part of the verbose output will tell you where on the remote machine the
        # module was written to::
        #   [...]
        #   <host1> SSH: EXEC ssh -C -q -o ControlMaster=auto -o ControlPersist=60s -o KbdInteractiveAuthentication=no -o
        #   PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o ConnectTimeout=10 -o
        #   ControlPath=/home/badger/.ansible/cp/ansible-ssh-%h-%p-%r -tt rhel7 '/bin/sh -c '"'"'LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8
        #   LC_MESSAGES=en_US.UTF-8 /usr/bin/python /home/badger/.ansible/tmp/ansible-tmp-1461173013.93-9076457629738/ping'"'"''
        #   [...]
        #
        # Login to the remote machine and run the module file via from the previous
        # step with the explode subcommand to extract the module payload into
        # source files::
        #   $ ssh host1
        #   $ /usr/bin/python /home/badger/.ansible/tmp/ansible-tmp-1461173013.93-9076457629738/ping explode
        #   Module expanded into:
        #   /home/badger/.ansible/tmp/ansible-tmp-1461173408.08-279692652635227/ansible
        #
        # You can now edit the source files to instrument the code or experiment with
        # different parameter values.  When you're ready to run the code you've modified
        # (instead of the code from the actual zipped module), use the execute subcommand like this::
        #   $ /usr/bin/python /home/badger/.ansible/tmp/ansible-tmp-1461173013.93-9076457629738/ping execute

        # Okay to use __file__ here because we're running from a kept file
        basedir = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'debug_dir')
        args_path = os.path.join(basedir, 'args')

        if command == 'explode':
            # transform the ZIPDATA into an exploded directory of code and then
            # print the path to the code.  This is an easy way for people to look
            # at the code on the remote machine for debugging it in that
            # environment
            z = zipfile.ZipFile(zipped_mod)
            for filename in z.namelist():
                if filename.startswith('/'):
                    raise Exception('Something wrong with this module zip file: should not contain absolute paths')

                dest_filename = os.path.join(basedir, filename)
                if dest_filename.endswith(os.path.sep) and not os.path.exists(dest_filename):
                    os.makedirs(dest_filename)
                else:
                    directory = os.path.dirname(dest_filename)
                    if not os.path.exists(directory):
                        os.makedirs(directory)
                    f = open(dest_filename, 'wb')
                    f.write(z.read(filename))
                    f.close()

            # write the args file
            f = open(args_path, 'wb')
            f.write(json_params)
            f.close()

            print('Module expanded into:')
            print('%s' % basedir)
            exitcode = 0

        elif command == 'execute':
            # Execute the exploded code instead of executing the module from the
            # embedded ZIPDATA.  This allows people to easily run their modified
            # code on the remote machine to see how changes will affect it.

            # Set pythonpath to the debug dir
            sys.path.insert(0, basedir)

            # read in the args file which the user may have modified
            with open(args_path, 'rb') as f:
                json_params = f.read()

            # Monkeypatch the parameters into basic
            from ansible.module_utils import basic
            basic._ANSIBLE_ARGS = json_params

            # Run the module!  By importing it as '__main__', it thinks it is executing as a script
            runpy.run_module(mod_name='ansible.modules.setup', init_globals=None, run_name='__main__', alter_sys=True)

            # Ansible modules must exit themselves
            print('{"msg": "New-style module did not handle its own exit", "failed": true}')
            sys.exit(1)

        else:
            print('WARNING: Unknown debug command.  Doing nothing.')
            exitcode = 0

        return exitcode

    #
    # See comments in the debug() method for information on debugging
    #

    ANSIBALLZ_PARAMS = '{"ANSIBLE_MODULE_ARGS": {"_ansible_check_mode": false, "_ansible_no_log": false, "_ansible_debug": false, "_ansible_diff": false, "_ansible_verbosity": 0, "_ansible_version": "2.16.6", "_ansible_module_name": "ansible.legacy.setup", "_ansible_syslog_facility": "LOG_USER", "_ansible_selinux_special_fs": ["fuse", "nfs", "vboxsf", "ramfs", "9p", "vfat"], "_ansible_string_conversion_action": "warn", "_ansible_socket": null, "_ansible_shell_executable": "/bin/sh", "_ansible_keep_remote_files": true, "_ansible_tmpdir": "/root/.ansible/tmp/ansible-tmp-1714837072.6442196-34920-239177455970548/", "_ansible_remote_tmp": "~/.ansible/tmp"}}'
    if PY3:
        ANSIBALLZ_PARAMS = ANSIBALLZ_PARAMS.encode('utf-8')
    try:
        # There's a race condition with the controller removing the
        # remote_tmpdir and this module executing under async.  So we cannot
        # store this in remote_tmpdir (use system tempdir instead)
        # Only need to use [ansible_module]_payload_ in the temp_path until we move to zipimport
        # (this helps ansible-test produce coverage stats)
        temp_path = tempfile.mkdtemp(prefix='ansible_' + 'ansible.legacy.setup' + '_payload_')

        zipped_mod = os.path.join(temp_path, 'ansible_' + 'ansible.legacy.setup' + '_payload.zip')

        with open(zipped_mod, 'wb') as modlib:
            modlib.write(base64.b64decode(ZIPDATA))

        if len(sys.argv) == 2:
            exitcode = debug(sys.argv[1], zipped_mod, ANSIBALLZ_PARAMS)
        else:
            # Note: temp_path isn't needed once we switch to zipimport
            invoke_module(zipped_mod, temp_path, ANSIBALLZ_PARAMS)
    finally:
        try:
            shutil.rmtree(temp_path)
        except (NameError, OSError):
            # tempdir creation probably failed
            pass
    sys.exit(exitcode)

if __name__ == '__main__':
    _ansiballz_main()
```
