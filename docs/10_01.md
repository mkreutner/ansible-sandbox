# 1. Gérer l'exécution des tâches asynchrones

## 1.1. L'exécution asynchrone

Par défaut, **Ansible** exécute les tâches de manière synchrone, maintenant la connexion au nœud distant ouverte jusqu'à ce que l'action soit terminée.

Cela signifie que, dans un **playbook**, chaque tâche bloque la suivante jusqu'à ce qu'elle soit terminée.

Nous allons voir comment utiliser le mode asynchrone pour gérer les tâches longues et éviter les blocages et les **timeouts**.

## 1.2. Le polling

Le **polling** est le mécanisme par lequel **Ansible** vérifie périodiquement l'état d'une tâche asynchrone.

Cela signifie que lorsque vous lancez une tâche asynchrone, **Ansible** peut continuer à exécuter d'autres tâches, mais reviendra régulièrement vérifier si la tâche asynchrone est terminée ou non, selon l'intervalle de **polling** spécifié.

Par défaut, **Ansible** utilise un intervalle de **polling** défini par la variable `DEFAULT_POLL_INTERVAL`.

Si cette variable n'est pas spécifiée dans la configuration, le polling est désactivé, c'est-à-dire que la valeur de **poll** est de **0**. Cela signifie qu'Ansible n'attendra pas la fin de la tâche asynchrone avant de passer à la suivante, permettant ainsi l'exécution concurrente des tâches.

## 1.3. Syntaxe pour les tâches ad hocs

Il est possible d'utiliser le **CLI** pour lancer des tâches asynchrones.

Pour ce faire, il faut utiliser l'option **-B** (pour **--background**) et spécifier un délai de timeout en secondes :

```SHELL
ansible all -B 60 -a "/bin/sleep 30" -i inventory.yml
```

Vous pouvez préciser l'intervalle de **polling** avec **-P** :

```SHELL
ansible all -B 60 -P 10 -a "/bin/sleep 30" -i inventory.yml
```

Vous pouvez désactiver le **polling** :

```SHELL
ansible all -B 60 -P 0 -a "/bin/sleep 30" -i inventory.yml
```

Dans ce cas la tâche s'exécute en fond mais il n'y a plus de vérification périodique.

Vous obtiendrez un identifiant pour chaque tâche :

```JSON
node2 | CHANGED => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "ansible_job_id": "j902871853450.2205",
    "changed": true,
    "finished": 0,
    "results_file": "/root/.ansible_async/j902871853450.2205",
    "started": 1
}
node1 | CHANGED => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "ansible_job_id": "j915016945232.2202",
    "changed": true,
    "finished": 0,
    "results_file": "/root/.ansible_async/j915016945232.2202",
    "started": 1
}
```

Vous pourrez alors contrôler le statut de chaque tâche avec le module **async_status** :

```SHELL
ansible all -m ansible.builtin.async_status -a "jid=j986002286141.2442" -i inventory.yml
```

Notez le ``jid=`` passé en argument avant l'identifiant.

## 1.4. Syntaxe pour les playbooks

Voici la syntaxe à utiliser :

```YAML
- hosts: all

  tasks:
  - name: Simulate a long operation (15 seconds), wait up to 45 seconds, check every 5 seconds
    ansible.builtin.command: /bin/sleep 15
    async: 45
    poll: 5
```

Pour suivre une tâche, on peut également utiliser **async_status** :

```YAML
- hosts: all

  tasks:
  - name: Execute an asynchronous task
    ansible.builtin.apt:
      name: nginx
      state: present
    async: 1000
    poll: 0
    register: apt_sleeper

  - name: Check an asynchronous task
    async_status:
      jid: "{{ apt_sleeper.ansible_job_id }}"
    register: job_result
    until: job_result.finished
    retries: 100
    delay: 10
```

Le suivi est ici bloquant, mais vous pouvez exécuter d'autres tâches pendant l'exécution de la tâche asynchrone :

```YAML
- hosts: all

  tasks:
  - name: Execute an asynchronous task
    ansible.builtin.apt:
      name: nginx
      state: present
    async: 1000
    poll: 0
    register: apt_sleeper

  - name: Another task that is not blocked
    ansible.builtin.debug:
      msg: "I'll do it!"

  - name: Check an asynchronous task
    async_status:
      jid: "{{ apt_sleeper.ansible_job_id }}"
    register: job_result
    until: job_result.finished
    retries: 100
    delay: 10
```

## 1.5. Avancé : exécuter des tâches asynchrones en lot

Voici comment faire pour exécuter par exemple deux par deux des tâches asynchrones.

Créez un fichier **batch_control.yml** :

```YAML
- hosts: all
  tasks:
    - name: Exécuter des éléments de manière asynchrone par lots de deux éléments
      vars:
        sleep_durations:
          - 1
          - 2
          - 3
          - 4
          - 5
        durations: "{{ item }}"
      include_tasks: execute_batch.yml
      loop: "{{ sleep_durations | batch(2) }}"
```

Nous reverrons l'**inclusion** plus tard en détail, vous retenir pour l'instant que cette directive inclut et exécute un fichier de tâches externe nommé **execute_batch.yml**.

`loop: "{{ sleep_durations | batch(2) }}"` : utilise une boucle pour itérer sur la liste **sleep_durations**, mais en divisant la liste en sous-listes (**batches**) de deux éléments chacune :

- **sleep_durations** : la liste des durées de sommeil.
- **| batch(2)** : un filtre qui divise la liste en sous-listes de deux éléments.

Et créez le fichier **execute_batch.yml** :

```YAML
- name: Asynchronous sleep for batch elements
  ansible.builtin.command: sleep {{ async_item }}
  async: 45
  poll: 0
  loop: "{{ durations }}"
  loop_control:
    loop_var: "async_item"
  register: async_results

- name: Check the synchronization status
  async_status:
    jid: "{{ async_result_item.ansible_job_id }}"
  loop: "{{ async_results.results }}"
  loop_control:
    loop_var: "async_result_item"
  register: async_poll_results
  until: async_poll_results.finished
  retries: 30
```

- **async_status: jid: "{{ async_result_item.ansible_job_id }}"** : utilise le module **async_status** pour vérifier l'état de la tâche asynchrone en utilisant l'identifiant de job (**jid**) enregistré dans la variable **async_result_item.ansible_job_id**.
- **loop: "{{ async_results.results }}"** : utilise une boucle pour vérifier l'état de chaque tâche asynchrone enregistrée dans **async_results**.
- **loop_control: loop_var: "async_result_item"** : spécifie que la variable de boucle utilisée dans cette tâche est **async_result_item**.
- **register: async_poll_results** : enregistre les résultats de la vérification de l'état dans une variable appelée **async_poll_results**.
- **until: async_poll_results.finished** :cette tâche continue de vérifier l'état jusqu'à ce que chaque tâche soit terminée (**finished**).
- **retries: 30** : définit le nombre maximal de tentatives de vérification de l'état à 30 fois.
- **delay: 10** : définit un délai de 10 secondes entre chaque tentative de vérification de l'état.