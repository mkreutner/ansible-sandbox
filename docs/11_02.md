# 2. Inclure et importer

## 2.1. Inclure et importer

L'utilisation des instructions **include** et **import** permet de structurer vos **playbooks** de manière modulaire et réutilisable. 

Les instructions **include** et **import** sont très similaires, mais le moteur d'exécution d'Ansible les traite de manière très différente :

- **import\*** : toutes les instructions **import** sont pré-traitées au moment où les **playbooks** sont analysés.
- **include\*** : toutes les instructions **include** sont traitées au fur et à mesure de leur rencontre pendant l'exécution du playbook.

Cette différence signifie que les **import\*** sont statiques et les **include\*** sont dynamiques. 

## 2.2. Importer des playbooks, des tâches et des rôles

### 2.2.1.Importer des playbooks

Importer des **playbooks** permet de diviser un grand **playbook** en plusieurs fichiers plus petits et réutilisables.

Chaque **playbook** importé est traité comme s'il était défini directement dans le **playbook** principal.

Par exemple :

```YAML
# master_playbook.yml
- import_playbook: configuration_webservers.yml
- import_playbook: configuration_databases.yml
- import_playbook: configuration_loadbalancers.yml
```

### 2.2.2. Importer des fichiers de tâches

Importer des fichiers de tâches permet de réutiliser des ensembles de tâches dans différents **playbooks** ou sections de **playbooks**.

Par exemple :

```YAML
# common_tasks.yml
- name: Install dependencies
  ansible.builtin.package:
    name:
      - curl
      - git
    state: present

- name: Create application user
  ansible.builtin.user:
    name: appuser
    state: present
```

```YAML
# main_playbook.yml
- hosts: all
  tasks:
    - import_tasks: common_tasks.yml
```

### 2.2.3. Passer des variables dans les imports

Vous pouvez passer des variables spécifiques lors de l'importation de fichiers de tâches, ce qui permet de personnaliser les tâches importées.

```YAML
# deploy_app.yml
- name: Deploy application
  ansible.builtin.git:
    repo: 'https://github.com/example/repo.git'
    dest: /var/www/myapp
    version: "{{ app_version }}"
```

```YAML
# main_playbook.yml
- hosts: webservers
  tasks:
    - import_tasks: deploy_app.yml
      vars:
        app_version: v1.0.0

    - import_tasks: deploy_app.yml
      vars:
        app_version: v1.1.0
```

### 2.2.4. Importer des rôles

Les rôles peuvent être importés pour être exécutés de manière statique.

```YAML
- hosts: webservers
  tasks:
    - import_role:
        name: common
    - import_role:
        name: webserver
```

## 2.3. Utilisation d'includes pour des playbooks, des tâches et des rôles

Les **includes** sont évalués au moment de l'**exécution** du **playbook**, ce qui permet de réagir aux conditions lors de l'exécution et de réutiliser les tâches de manière flexible.

### 2.3.1. Inclusion dynamique (include_tasks)

**include_tasks** est utilisé pour inclure un fichier de tâches au moment de l'exécution. Cela permet de réutiliser des ensembles de tâches et de les exécuter sous certaines conditions ou dans des boucles.

Il est aussi possible d'utiliser des variables.

Par exemple :

```YAML
# create_user.yml
- name: Create user
  ansible.builtin.user:
    name: "{{ user_name }}"
    state: present
```

```YAML
# main_playbook.yml
- hosts: all
  tasks:
    - include_tasks: create_user.yml
      vars:
        user_name: john

    - include_tasks: create_user.yml
      vars:
        user_name: jane
```

### 2.3.2. Utilisation de boucles avec include

Les inclusions dynamiques permettent d'utiliser des boucles, ce qui n'est pas possible avec les imports statiques.

```YAML
# install_packages.yml
- name: Install package
  ansible.builtin.apt:
    name: "{{ item }}"
    state: present
```

```YAML
# main_playbook.yml
- hosts: all
  tasks:
    - name: Dynamic include of tasks using loop
      include_tasks: install_packages.yml
      loop:
        - git
        - curl
        - htop
```

#### 2.3.2.1. include_role

**include_role** est utilisé pour inclure des rôles de manière dynamique. 

```YAML
# main_playbook.yml
- hosts: webservers
  tasks:
    - include_role:
        name: common

    - include_role:
        name: webserver
```

#### 2.3.2.2. include_vars

**include_vars** est utilisé pour inclure des fichiers de variables. Cela permet de charger des configurations spécifiques en fonction de l'environnement ou d'autres critères.

```YAML
# vars/prod.yml
app_environment: production
db_host: prod-db.example.com
```

```YAML
# vars/dev.yml
app_environment: development
db_host: dev-db.example.com
```

```YAML
# main_playbook.yml
- hosts: all
  tasks:
    - include_vars: "vars/{{ ansible_environment }}.yml"
```

Dans cet exemple, les variables sont incluses dynamiquement en fonction de la valeur de **ansible_environment**, permettant de charger des configurations spécifiques pour différents environnements (production, development, etc.).

## 2.4. Comparaison des includes et imports

### 2.4.1. Avantages des includes

- **Boucles** : ils permettent d'exécuter des tâches ou des rôles plusieurs fois avec des éléments différents dan

s une boucle.
- **Flexibilité** : ils peuvent réagir dynamiquement aux conditions rencontrées pendant l'exécution du **playbook**.

### 2.4.2. Inconvénients des includes

- **Visibilité** : les **tags** et les tâches internes aux **includes** dynamiques ne s'affichent pas dans la sortie `--list-tags` ou `--list-tasks`.
- **Notification** : impossible d'utiliser **notify** pour déclencher un **handler** dont le nom provient d'un **include** dynamique.
- **Débogage** : `--start-at-task` ne peut pas commencer l'exécution à une tâche à l'intérieur d'un **include** dynamique.

### 2.4.3. Avantages des imports

- **Consistance** : les options de tâche du parent sont héritées par toutes les tâches enfants.
- **Prévisibilité** : toutes les tâches sont pré-traitées, ce qui peut simplifier le débogage et la planification.

### 2.4.4. Inconvénients des imports

- **Boucles** : ils ne peuvent pas être utilisés avec des boucles.
- **Variables** : les variables provenant de sources d'inventaire (hôtes/groupes) ne peuvent pas être utilisées pour déterminer le fichier cible ou le nom du rôle.