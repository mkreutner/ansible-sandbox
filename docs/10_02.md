# 2. Les stratégies et autres configurations pour contrôler l'exécution des playbooks

## 2.1. Exécution par défaut

Par défaut, **Ansible** exécute chaque tâche sur tous les hôtes ciblés par un **play** avant de commencer la tâche suivante sur n'importe quel hôte, en utilisant 5 **forks**.

Un fork se réfère au nombre de processus parallèles qu'**Ansible** utilise pour exécuter des tâches sur les hôtes cibles.

Par exemple, si vous avez 10 hôtes à configurer et que vous utilisez les 5 **forks** par défaut, **Ansible** configurera 5 hôtes à la fois, puis passera aux 5 suivants une fois les premiers terminés.

Si vous souhaitez changer ce comportement par défaut, vous pouvez utiliser un plugin de stratégie différent, modifier le nombre de **forks** ou appliquer l'un des plusieurs mots-clés comme **serial**.

## 2.2. Les stratégies d'exécution

### 2.2.1. Stratégie par défaut

La stratégie **linéaire** est le comportement par défaut dans **Ansible**.

Cela signifie qu'**Ansible** exécute chaque tâche sur tous les hôtes affectés par un **play** avant de passer à la tâche suivante.

Voici les caractéristiques principales de cette stratégie :

- **Exécution par tâche** :
  - **Ansible** exécute une tâche spécifique sur tous les hôtes avant de passer à la tâche suivante.
  - Par exemple, si une tâche **command: hostname** est définie, **Ansible** s'assure que cette tâche est complétée sur tous les hôtes avant de passer à une autre tâche, comme **command: uptime**.
- **Ordre séquentiel** :
  - L'ordre d'exécution est **séquentiel** et prévisible. Cela garantit que toutes les tâches sont exécutées dans l'ordre exact dans lequel elles sont définies dans le **playbook**.
  - Cela aide à maintenir la cohérence et la prévisibilité dans le déploiement, car chaque tâche doit être complétée sur tous les hôtes avant que la suivante ne commence.
- **Blocage des hôtes lents** : un inconvénient majeur de cette stratégie est que si un hôte prend plus de temps pour compléter une tâche, cela retardera l'exécution de la tâche suivante pour tous les hôtes. Les hôtes rapides doivent attendre que les hôtes lents terminent.

### 2.2.2. La stratégie free

La stratégie **free** permet l'exécution des tâches aussi rapidement que possible par lot, tel que défini par **serial** (par défaut, tous).

**Ansible** ne va pas attendre que tous les autres hôtes terminent la tâche en cours avant d'ordonner plus de tâches pour les autres hôtes. 

Avec la stratégie **free**, contrairement à la stratégie linéaire par défaut, un hôte qui est lent ou bloqué sur une tâche spécifique ne retiendra pas les autres hôtes et tâches.

```YAML
- hosts: all
  strategy: ansible.builtin.free
  tasks:
    - name: Execute a simple command
      ansible.builtin.command: hostname
    - name: Wait 5 seconds
      ansible.builtin.command: sleep 5
    - name: Execute another command
      ansible.builtin.command: uptime
```

#### Avantages :

1. **Efficacité accrue** :
   - La stratégie **free** permet aux tâches de s'exécuter aussi rapidement que possible sans être retardées par des hôtes plus lents.
   - Les hôtes rapides ne sont pas obligés d'attendre que les hôtes plus lents terminent leurs tâches (parallélisme des tâches).
2. **Réduction des blocages** :
   - Les hôtes qui sont bloqués ou qui prennent plus de temps pour terminer une tâche ne bloquent pas l'avancement des autres hôtes.
   - Cela améliore l'efficacité globale du **playbook**, en particulier dans les environnements hétérogènes avec des performances d'hôte variables.

#### Inconvénients potentiels :

1. **Gestion des dépendances** : si certaines tâches dépendent des résultats d'autres tâches sur différents hôtes, la stratégie **free** peut compliquer la gestion des dépendances, car les tâches peuvent terminer à des moments différents sur différents hôtes.
2. **Complexité accrue** : l'utilisation de la stratégie **free** peut rendre plus difficile le suivi de l'ordre d'exécution et le débogage des playbooks, car les tâches ne s'exécutent pas de manière strictement séquentielle.

### 2.2.3. Stratégie debug

La stratégie **debug** est utilisée pour déboguer les **playbooks** en permettant une interaction pas à pas avec les tâches. Voici ses caractéristiques :

- **Débogage interactif** : permet aux utilisateurs d'interagir avec l'exécution des tâches, de vérifier les états intermédiaires et de prendre des décisions basées sur les résultats en temps réel.
- **Interruption et inspection** : permet de suspendre l'exécution après chaque tâche pour inspecter l'état actuel des hôtes et des variables.

```YAML
- hosts: all
  strategy: debug
  tasks:
    - name: Execute a simple command
      ansible.builtin.command: hostname
```

## 2.3. Définir le nombre de forks

Si vous disposez de la puissance de traitement nécessaire et souhaitez utiliser plus de forks, vous pouvez définir le nombre dans `ansible.cfg` :

```INI
[defaults]
forks = 30
```

Le nombre de forks optimal pour votre environnement **Ansible** dépend de plusieurs facteurs, notamment la puissance de traitement disponible sur votre machine de contrôle, le nombre total d'hôtes à gérer, et les ressources réseau disponibles.

Le mieux est de définir graduellement le nombre de forks sur votre nœud de contrôle optimal en procédant de cette façon :

- Commencez avec le nombre par défaut de **forks** (`5`) et augmentez progressivement le nombre.
- Surveillez l'impact sur les performances de votre machine de contrôle et les temps d'exécution des **playbooks** (avec les commandes **free**, **top** et **htop**).
- Utilisez une commande comme `ansible-playbook -f 10 my_playbook.yml` pour tester différents nombres de **forks**.
- Notez les temps d'exécution des **playbooks** pour différents nombres de **forks**.
- Cherchez un point où l'augmentation des **forks** n'améliore plus significativement les temps d'exécution ou commence à dégrader les performances.

## 2.4. Définir la taille des lots avec serial

Par défaut, **Ansible** s'exécute en parallèle sur tous les hôtes du motif que vous définissez dans le champ **hosts:** de chaque **play**, bien sûr en utilisant le nombre de **forks** défini.

Si vous souhaitez gérer uniquement quelques machines à la fois, par exemple lors d'une mise à jour progressive, vous pouvez définir combien d'hôtes **Ansible** doit gérer en même temps en utilisant le mot-clé **serial** :

```YAML
- name: Test play
  hosts: webservers
  serial: 3
  gather_facts: False
  tasks:
    - name: Get hostanme task
      command: hostname
    - name: Get all IP addresses task
      command: hostname --all-ip-addresses
```

Vous pouvez également spécifier un pourcentage avec le mot-clé **serial**. **Ansible** applique le pourcentage au nombre total d'hôtes dans un **play** pour déterminer le nombre d'hôtes par passage :

```YAML
---
- name: Test play
  hosts: webservers
  serial: "30%"
```

Si le nombre d'hôtes ne se divise pas également dans le nombre de passages, le dernier passage contient le reste.

## 2.5. Restreindre l'exécution d'une tâche avec throttle

Le mot-clé **throttle** limite le nombre de travailleurs pour une tâche particulière.

Il peut être défini au niveau du bloc et de la tâche.

Utilisez **throttle** pour restreindre les tâches qui peuvent être intensives en **CPU** ou interagir avec une **API** à limitation de débit :

```YAML
tasks:
- command: /task_high_cpu_usage.py
  throttle: 1
```

## 2.6. Ordonner l'exécution en fonction de l'inventaire

Le mot-clé **order** contrôle l'ordre dans lequel les hôtes sont exécutés. Les valeurs possibles pour **order** sont :

- **inventory** : (par défaut) l'ordre fourni par l'inventaire pour la sélection demandée (voir la note ci-dessous)
- **reverse_inventory** : comme ci-dessus, mais en inversant la liste retournée
- **sorted** : trié alphabétiquement par nom
- **reverse_sorted** : trié par nom en ordre alphabétique inversé
- **shuffle** : ordonné aléatoirement à chaque exécution

## 2.7. Exécution sur une seule machine avec run_once

Si vous souhaitez qu'une tâche s'exécute uniquement sur le premier hôte de votre lot d'hôtes, définissez **run_once** sur `true` pour cette tâche :

```YAML
---
# ...
  tasks:
    # ...
    - command: /task_to_exec_one_time.py
      run_once: true
```

**Ansible** exécute cette tâche sur le premier hôte du lot actuel et applique tous les résultats et faits à tous les hôtes du même lot.
